# JavaScript

## 介绍

JavaScript 是一种轻量级的脚本语言。

JavaScript 也是一种嵌入式语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O 相关的 API, 都要靠宿主环境提供。

从语法角度看，JavaScript 语言是一种"对象模型"语言，各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的"面向对象语言", 还支持其他编程范式。

JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符，控制结构，语句）和标准库 (Array,Date,Math 等）. 除此之外，各种宿主环境提供额外的 API, 以便 JavaScrip 调用。以浏览器为例，它提供的额外 API 可以分成三大类。

- 浏览器控制类：操作浏览器
- DOM 类：操作网页的各种元素
- Web 类。实现互联网的各种功能

## 基本语法

1. 语句和表达式
    JavaScript 程序的执行单位为行 (line), 也就是一行一行地执行。一般清空下，每一行就是一个语句。
    `语句 (statement)` 是为了完成某种任务而进行的操作。
    `表达式(expression)`指一个为了得到返回值的计算式。
    语句以分号结尾，一个分号就表示一个语句结束，多个语句可以写在一行内。
    表达式不需要分号结尾。

2. 变量和变量提升
    `变量`就是对"值"的具名引用。变量就是为"值"起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。
    注意，JavaScript 的`变量名区分大小写`。
    如果只是声明变量而没有赋值，则该变量的值是`undefined`
    JavaScript 是一种`动态类型语言`，也就是说，变量的类型没有限制，变量可以随时更改类型。
    JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做`变量提升` (hoisting)

3. 标识符
    `标识符(identifer)`指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。
    标识符的命名规则如下。
      第一个字符：可以是任意 Unicode 字母，以及美元符号 (`$`) 和下划线 (`_`)
      第二个字符及后面的字符，除了 Unicode 字母，美元符号和下划线，还可以用数字`0-9`
    JavaScript 还有一些保留字，不能用作标识符

4. 注释
    源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，另一种是多行注释。

5. 区块
    JavaScript 使用大括号，将多个相关的语句组合在一起，称为"区块"(block)
    对于`var`命令来说，JavaScript 的区块不构成单独的作用域 (scope)
    在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如`for`,`if`,`while`,`function`等

6. 条件语句
  if
  if...else
  switch
  ?:

7. 循环语句
  while
  for
  do...while
  break 和 continue
  标签 label

## 数据类型

### 简介

JavaScript 语言的每一个值，都属于一种数据类型。JavaScript 的数据类型，共有六种，ES6 又新增了第七种 Symbol 类型的值

`数值`，`字符串`，`布尔值`，`undefined`,`null`, `对象`

数值，字符串，布尔值这三种类型，合称为原始类型。
对象则称为合成类型。
undefined 和 null, 一般将它们看成两个特殊值。

对象是最复杂的数据类型，又可以分成三个子类型：狭义的对象，数组，函数

### typeof 运算符

JavaScript 有三种方法，可以确定一个值到底是什么类型

- `typeof` 运算符
- `instancof` 运算符
- `Object.prototype.toString` 方法

`typeof`运算符可以返回一个值的数据类型

数值，字符串，布尔值分别返回`number`,`string`,`boolean`, 函数返回`function`

`undefined`返回`undefined`, 利用这一点，`typeof`可以用来检查一个没有声明的变量，而不报错。

对象返回`object`,`null`返回`object`, 这是由于历史原因造成的。

### 1. null,undefined 和布尔值

`null` 表示空值，即该处的值现在为空。`undefined` 表示"未定义"

布尔值代表"真"(`true`) 和"假"(`false`) 两个状态。布尔值只有这两个值。

下列运算符会返回布尔值：
- 前置逻辑运算符：`!`(Not)
- 相等运算符：`===`,`!==`,`==`,`!=`
- 比较运算符：`>`,`>=`,`<`,`<=`

如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则除了下面六个值被转为`false`, 其他值都视为`true`

- `undefined`
- `null`
- `false`
- `0`
- `NaN`
- `""`或`''`

布尔值往往用于程序流程的控制。
注意，空数组（[]）和空对象（{}）对应的布尔值，都是 true。

### 2. 数值

JavaScript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。由于浮点数不少精确的值，所以涉及小数的比较和运算都要特别小心。

如果一个数大于等于 2 的 1024 次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回`Infinity`
如果一个数小于等于 2 的 -1075 次方，那么就会发生"负向溢出", 即 JavaScript 无法表示这么小的数，这时就会直接返回 0

JavaScript 的数值有多种表示方法，可以用字面形式直接表示，也可以采用科学计算法表示。
使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。默认情况下，JavaScript 会自动将其他进制转为十进制。

JavaScript 提供了几个特殊的数值
`正零和负零`：正零和负零都会被当作正常的 0, 唯一有区别的场合是，+0 或 -0 当作分母，返回的值是不相等的。
`NaN`:NaN 是 JavaScript 的特殊值，表示"非数字", 主要出现在将字符串解析成数字出错的场合，另外，一些数学函数的运算结果会出现`NaN`,0 除以 0 也会得到 NaN, 需要注意的是，NaN 不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于`Number`

NaN 不等于任何值，包括它本身，NaN 在布尔运算时被当作 false,NaN 与任何数运算，得到的都是 NaN

`Infinity`表示"无穷", 用来表示两种场景，一种是一个正的数值太大，或一个负的数值太小，或一个负数的值太小，无法表示；另一种是非 0 数值除以 0, 得到`Infinity`

`Infinity`有正负之分，`Infinity`表示正的无穷，`-Infinity`表示负的无穷。

`Infinity`大于一切数值（除了`NaN`），`-Infinity`小于一切数值（除了`NaN`）。`Infinity` 与 `NaN` 比较，总是返回 `false`。

`Infinity`的四则运算，符合无穷的数学计算规则。

数值相关的全局方法：`parseInt()`和`parseFloat()`,`isNaN()`,`isFinite()`

### 3. 字符串

`字符串`就是零个或多个排在一起的字符，放在单引号或双引号之中。
`单引号`字符串的内部，可以使用双引号。`双引号`字符串的内部，可以使用单引号

如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上`反斜杠`，用来转义。双引号字符串内部使用双引号，也是如此。

如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。
连接运算符（`+`）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。

反斜杠 (`\`) 在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。

字符串可以被视为`字符数组`，因此可以使用数组的方括号运算符，用来返回某个位置的字符。但是，字符串与数组的相似性仅此而已。

`length`属性返回字符串的长度，该属性也是无法改变的。

JavaScript 使用 `Unicode 字符集`。JavaScript 引擎内部，所有字符都用 Unicode 表示。解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。

JavaScript 原生提供两个`Base64`相关的方法。

- `btoa()`：任意值转为 Base64 编码
- `atob()`：Base64 编码转为原来的值

注意，这两个方法不适合非 ASCII 码的字符，会报错。要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。
`encodeURIComponent()`,`decodeURIComponent()`

### 4. 对象

`对象`是 JavaScript 语言的核心概念，也是最重要的数据类型。
什么是对象？简单说，对象就是一组"键值对"的集合，是一种无序的复合数据集合。

对象的所有键名都是字符串 (ES6 又引入了 Symbol 值也可以作为键名）, 所以加不加引号都可以。如果键名是数值，会被自动转为字符串。如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。

对象的每一个键名又称为"属性"(property), 它的"键值"可以是任何数据类型。如果一个属性的值为安徽你是，通常把这个属性称为"方法", 它可以像函数那样调用。
如果属性的值还是一个对象，就形成了链式引用

对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。
属性可以动态创建，不必再对象声明时就指定。

如果不同的变量名指向同一个对象，那么它们就是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。

此时，如果取消某一个变量对于原变量的引用，不会影响到另一个变量。
但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。

对象采用大括号表示，这导致一个问题：如果行首是一个大括号，它到底是表达式还是语句？

JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块
如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。

读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。
方括号运算符还可以使用表达式。
数字键可以不加以引号，因为会自动转成字符串。
注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。

点运算符和方括号运算符，不加可以用来读取值，还可以用来赋值。
JavaScript 允许属性的"后绑定", 也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。

查看一个对象本身的所有属性，可以使用`Object.keys`方法。

`delete`命令用于删除对象的属性，删除成功后返回`true`
注意，删除一个不存在的属性，`delete`不会报错，而且返回`true`
另外一种情况，`delete`命令会返回`false`, 那就是该属性存在，且不得删除。
另外，需要注意的是，delete 命令只能删除对象本身的属性，无法删除继承的属性。

`in`运算符用于检查对象是否包含某个属性，如果包含就返回`true`, 否则返回`false`

`in`运算符的一个问题是它不能失败哪些属性是对象自身的，哪些属性是继承的。这时，可以使用对象的`hasOwnProperty`方法判断一下，是否为对象自身的属性。

`for...in`循环用来遍历一个对象的全部属性。
`for...in`循环有两个使用注意点。
- 它遍历的是对象所有可遍历的属性，会跳过不可遍历的属性。
- 它不仅遍历对象自身的属性，还遍历继承的属性

使用`for...in` 的时候，应该结合使用 `hasOwnProperty` 方法，在循环内部判断一下，某个属性是否为对象自身的属性。

### 5. 函数

>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。

`函数的声明`：1.function 命令，2. 函数表达式，3.Function 构造函数

如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。

调用函数时，要使用`圆括号运算符`。圆括号之中，可以加入函数的参数。
函数体内部的`return`语句，表示返回。JavaScript 引擎遇到`return`语句，就直接返回`return`后面的那个表达式的值，后面即使还有语句，也不会得到执行。

函数可以调用自身，这就是`递归`。

JavaScript 语言将函数看作一种值，与其他值地位相同。凡是可以使用值的地方，就能使用函数。由于函数与其他类型地位平等，所以在 JavaScript 语言中又函数为`第一等公民`。

`函数名的提升`:JavaScript 引擎将函数名视同变量名，所以采用 function 命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。

函数的`name`属性返回函数的名字。如果是通过变量赋值定义的函数，那么`name`属性返回变量名。如果变量的值是一个具名函数，那么 name 属性返回 function 关键字之后的那个函数名。
name 属性的一个用处，就是获取参数函数名字。

函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。
length 属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的"方法重载"

函数的`toString()`方法返回一个字符串，内容是函数的源码。
对于哪些原生的函数，`toString()`方法返回`function(){[native code]}`

`作用域`指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，另一种是函数作用域，ES6 又新增了块级作用域。

对于顶层函数来说，函数外部声明的变量就是全局变量，它可以在函数内部读取。
在函数内部定义的变量，外部无法读取，称为"局部变量"

函数内部定义的变量，会在该作用域内覆盖同名全局变量。
注意，对于`var`命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。

与全局作用域一样，`函数内部`也会产生"变量提升"现象。`var`命令声明的变量，不管在什么位置，变量声明都会`提升`到函数体的头部。

`函数本身也是一个值，也有自己的作用域`。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。同样的，函数体内部声明的函数，作用域绑定函数体内部。

函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫`参数`。`函数参数不是必需的`，JavaScript 允许省略参数。省略的参数的值会变为 undefined, 需要注意的是，函数`length`属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。

但是，没有办法只省略靠前的参数，而保留靠后的参数，如果一定要省略靠前的参数，只有显式传入`undefined`

函数参数如果是原始类型的值（数值，字符串，布尔值）, 传递方式是`传值传递`. 这意味着，在函数体内修改参数值，不会影响到函数外部。
但是，如果函数是复合类型的值（数组，对象，其他函数）, 传递方式是`传址传递`. 也就说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。
注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个函数，这时不会影响到原始值。

如果有`同名的参数`, 则取最后出现的那个值。

由于 JavaScript 允许函数有不定目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是`arguments`对象的由来。

`arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。

正常模式下，`arguments`对象可以在运行时修改。
严格模式下，`arguments`对象不会影响到实际的函数参数。
通过`arguments`对象的`length`属性，可以判断函数调用时到底带几个参数。

需要注意的是，虽然`arguments`很像数组，但它是一个对象。数组专有的方法，不能在`arguments`对象上直接使用。

如果要让`arguments`对象使用数组的方法，真正的解决方法是将`arguments`转为真正的数组。

`arguments`对象有一个`callee`属性，返回它所对应的原函数。可以通过`arguments.callee`属性，达到调用自身的目的。这个属性在严格模式是禁用的，因此不建议使用。

`闭包(closure)`是 JavaScript 语言的一个难点，也是它的特色。
理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。但是，函数外部无法读取函数内部声明的变量。

如果出于钟钟原因，需要得到含内的局部变量。正常情况下，这是办不到的，只能通过变通方法才能实现。那就是在函数的内部，再定义一个函数。

函数`f2`在函数`f1`内部，这时`f1`内部的所有局部变量，对`f2`都是可见的。但是反过来就不行，`f2`内部的局部变量，对`f1`就是不可见的。这就是 JavaScript 语言特有的"链式作用域"结构 (chain scope), 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

既然`f2`可以读取`f1`的局部变量，那么只要把`f2`作为返回值，我们就可以在`f1`外部读取它的内部变量了吗！

```js
function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}

var result = f1();
result(); // 999
```

闭包就是函数`f2`, 即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包理解还曾"定义在一个函数内部的函数". 闭包的最大特点，就是它可以"记住"诞生的环境。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。

```js
function createIncrementor(start) {
  return function () {
    return start++;
  };
}

var inc = createIncrementor(5);

inc() // 5
inc() // 6
inc() // 7
```

闭包可以看作函数内部作用域的一个接口，为什么会这样呢？原因在于`inc`始终在内存中，而`inc`的存在依赖于`createIncrementor`, 因此也始终在内存中，不会再调用结束后，被垃圾回收机制回收。

闭包的另一个用处，是封装对象的私有属性和私有方法。

注意，外层函数每次运行，都会生成一个新的闭包。而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。

根据 JavaScript 的语法，圆括号`()`跟在函数名只会，表示调用该函数，比如，`print()`就表示调用`print`函数。
有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。产生错误的原因是，`function`这个关键字即可以当作语句，也可以当作表达式。当作表达式时，函数可以定义后直接加圆括号调用。

为了比较解析的歧义，JavaScript 规定，如果`function`关键字出现在行首，一律解释成语句。因此，引擎看到行首是`function`关键字之后，认为这一段都是函数定义，不应该以圆括号结尾，所以就报错了。

解决方法就是不要让`function`出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。

```js
(function(){ /* code */ }());
// 或者
(function(){ /* code */ })();
```

上面这两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表达式，而不是函数定义语句，所以就避免了错误。这就叫做"立即调用的函数表达式", 简称 `IIFE`

注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE, 可能就会报错。推而广之，任何让解释器以表达式处理函数定义的方法，都能产生同样的效果。

通常情况下，只对匿名函数使用这种"理解执行的函数表达式". 它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成一个单独的作用域，可以封装一些外部无法读取的私有变量。

### 6. 数组

`数组 (array)` 是按次序排列的一组值。每个只的位置都有编号（从 0 开始）, 整个数组用方括号表示。

除了在定义时赋值，数组也可以先定义后赋值。任何类型的数据，都可以放入数组。如果数组的元素还是数组，就形成了多维数组。

本质上，数组属于一种特殊的对象。`typeof`运算符返回的数组类型是`object`
数组的特殊性体现在，它的键名是按次序排列的一组整数 (0,1,2...)

由于数组成员的键名是固定的，因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。

注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值。
上一章说过，对象有两种读取成员的方法：点结构 (`object.key`) 和方括号结构 (`object[key]`). 但是，对于数值的键名，不能使用点结构。

数组的`length`属性，返回数组的成员数量。
只要是数组，就一定有`length`属性，该属性是一个动态的值，等于键名中的最大整数加上`1`

`length`属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到`length`设置的值。
清空数组的一个有效方法，就是将`length`属性设为 0
如果人为 i 二设置`length`大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。
如果人为设置`length`为不合法的值，JavaScript 会报错。
值得注意的是，由于数组本质上是一种对象，可以为数组添加属性，但是这不影响`length`属性的值。
如果为数组的键名是超出范围的数值，该键名会自动转为字符串。

检查某个键名是否存在的运算符`in`, 适用于对象，也适用于数组。
注意，如果数组的某个位置是空位，`in`运算符返回`false`

`for...in`循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。
但是，`for...in`不仅会遍历数组所有的数字键，还会遍历非数字键。所以。不推荐适用`for...in`遍历数组。

数组的遍历可以考虑适用`for`循环或`while`循环。数组的`forEach`方法也可以用来遍历数组。

当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位 (hole)
需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。

数组的空位是可以读取的，返回`undefined`
使用`delete`命令删除一个数组成员，会形成空位，并且不会影响`length`属性。`length`属性不会过滤空位，所以，使用`length`属性进行数组遍历，一定要非常小心。

数组的某个位置是空位，与某个位置是`undefined`, 是不一样的。如果是空位，使用数组的`forEach`方法，`for...in`结构，以及`Object.keys`方法进行遍历，空位都会被跳过。
如果某个位置是`undefined`, 遍历的时候就不会被跳过。
这就是说，空位就是数组没有这个元素，所以不会被遍历到，而`undefined`则表示数组有这个元素，值是`undefined`, 所以遍历不会跳过。

如果一个对象的所有键名都是正整数或零，并且有`length`顺序，那么这个对象就很像数组，语法上称为`类似数组的对象`

类似数组的对象的根本特征，就是具有`length`属性，只要有`length`属性，就可以被认为这个对象类似于数组。但是又一个问题，这种`length`属性不是动态值，不会随着成员的变化而变化。

典型的"类似数组的对象"是函数的`arguments`对象，以及大多数 DOM 元素集，还有字符串。数组的`slice`方法可以将"类似数组的对象"变为真正的数组。

除了转为真正的数组，"类似数组的对象"还有一个办法可以使用数组的方法，就是通过`call()`把数组的方法放到对象上面。

注意，这种方法比直接使用数组原生的`forEach`要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的 forEach 方法

## 运算符

- 算术运算符
  运算符是处理数据的基本方法，用来从现有的值得到新的值。JavaScript 提供了多种运算符，覆盖了所有主要的运算。

  加法运算符：`x+y`
  减法运算符：`x-y`
  乘法运算符：`x*y`
  除法运算符：`x/y`
  指数运算符：`x**y`
  余数运算符：`x%y`
  自增运算符：`++x`或者`x++`
  自减运算符：`--x`或者`x--`
  数值运算符：`+x`
  负数值运算符：`-x`

- 比较运算符
  比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件

  `>`大于运算符
  `<`运算符
  `<=`小于或等于运算符
  `>=`运算符
  `==`相等运算符
  `===`严格相等运算符
  `!=`不相等运算符
  `!==`完全不相等运算符

- 布尔运算符
  布尔运算符用于将表达式转为布尔值，一共包含四个运算符
  取反运算符：`!`
  且运算符：`&&`
  或运算符：`||`
  三元运算符：`?:`

- 二进制运算符
  二进制位运算符用于直接对二进制位进行计算，一共有 7 个

  二进制或运算符 (or): 符号为`|`
  二进制与运算符 (and): 符号为`&`
  二进制否运算符 (not): 符号为`~`
  异或运算符 (xor): 符号为`^`
  左移运算符 (left shift): 符号为`<<`
  右移运算符 (right shift): 符号位`>>`
  头部补零的右移运算符 (zero filled right shift): 符号位`>>>`

- 其他运算符，运算顺序

  `void`运算符的作用是执行一个表达式，然后不返回任何值，或者说返回`undefined`
  这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。

  ` 逗号运算符`用于对两个表达式求值，并返回后一个表达式的值。
  逗号运算符的一共用途是，在返回一共值之前，进行一些辅助操作。

  JavaScript 各种运算符的`优先级别`是不一样的。圆括号（`()`）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。

  左结合和右结合 (`=`,`?:`,`**`)

## 语法专题

### 数据类型的转换

JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。

虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。

强制转换主要指使用`Number()`,`String()`和`Boolean()`三个函数，手动将各种类型的值，分别转换成数字，字符串或者布尔值。

使用`Number`函数，可以将任意类型的值转化成数值。1. 原始类型值 2. 对象
`String()`含可以将任意类型的值转化成字符串
`Boolean()`函数可以将任意类型的值转为布尔值。

遇到以下三种清空时，JavaScript 会自动转化数据类型。
第一种情况，不同类型的数据互相运算。
第二种情况，对非布尔值类型的数据求布尔值。
第三种情况，对非数值类型的值使用一元运算符

### 错误处理机制

JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供`Error`构造函数，所有抛出的错误都是这个构造函数的实例。

JavaScript 语言标准只提到，`Error`实例对象必须具有`message`属性，表示出错时的提示信息。大多数 JavaScript 引擎，对`Error`实例还提供`name`和`stack`属性。

`Error`实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他 6 种错误对象。

`SyntaxError`对象是解析代码时发生的`语法错误`。
`ReferenceError`对象是`引用一个不存在的变量`时发生的错误。
`RangeError`对象是一个值`超出有效范围`时发生的错误。
`TypeError`对象是变量或参数`不是预期类型`时发生的错误。
`URIError`对象是 URI 相关函数的参数不正确是抛出的错误。
`EvalError`错误，额`eval`函数没有被正确执行时。

除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。

```js
function UserError(message) {
  this.message = message || '默认信息';
  this.name = 'UserError';
}

UserError.prototype = new Error();
UserError.prototype.constructor = UserError;
```

try...catch
throw
finally

### 编程风格

### console 对象与控制台

`console`对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出和标准错误。
`console`的常见用途有两个：调试程序，显式网页代码运行时的错误信息。提供一个命令行接口，用来与网页代码互动。

- console 对象的静态方法：
  `console.log`,`console.info()`,`console.debug()`
  `console`对象的所有方法，都可以被覆盖。因此可以按照自己的需要，定义`console.log`方法。
  `console.warn()`,`console.error()`
  `console.table()`
  `console.count()`
  `console.dir()`,`console.dirxml()`
  `console.assert() `
  `console.time()`，`console.timeEnd()`
  `console.group()`，`console.groupEnd()`，`console.groupCollapsed()`
  `console.trace(`)，`console.clear()`
- 控制台命令行 API
  `$_`,`$0-$4`,`$(selector)`,`$$(seletor)`,`$x(path)`,`inspect(object)`,`getEventListeners(object)`,`keys(object)`，`values(object)``onitorEvents(object[, events])` ，`unmonitorEvents(object[, events])`

  命令行 API 还提供以下方法：`clear()`,`copy(object)`,`dir(object)`,`dirxml(object)`

`debugger`语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到 debugger 语句时会自动停下。如果没有除错工具，debugger 语句不会产生任何结果，JavaScript 引擎自动跳过这一句。

## 标准库

### Object 对象

JavaScript 原生提供`Object`对象。JavaScript 的所有其他对象都继承自`Object`对象，即哪些对象都是`Object`的实例。

`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。

`Object`对象`本身的方法`：所谓"本身的方法"就是直接定义在`Object`对象的方法。
`Object`的`实例方法`：所谓实例方法就是定义在`Object`原型对象`Object.prototype`上的方法。它可以被`Object`实例直接使用。

`Object`本身是一个函数，可以当作工具方法使用，将任意值转为为对象。这个方法常用于保证某个值一定是对象。如果参数为空（或者为`undefined`和`null`),`object()`返回一个空对象。
`instanceof`运算符用来验证，一个对象是否为指定的构造函数。
如果参数是原始类型的值，`Object`方法将其转为对应的包装对象的实例。
如果`Object`方法的参数是一个对象，它总是返回该对象，即不用转换。利用这一点，可以写一个判断变量是否为对象的函数。

`Object`不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用`new`命令。`Object`构造函数的首要用途，是直接通过它来生成新对象。

`Object`构造函数的用法与工具方法很相似，几乎一模一样。使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。

所谓"静态方法", 是指部署在`Object`对象自身的方法。
`Object.keys()`,`Object.getOwnPropertyNames()`

除了静态方法，还有不少方法定义在`Object.property`对象。它们称为实例方法，所有`Object`的实例对象都继承了这些办法。

`Object`实例对象的方法，主要有以下六个。
- `Object.property.valueOf()`
- `Object.property.toString()`
- `Object.property.toLocaleString()`
- `Object.property.hasOwnProperty()`
- `Object.property.isPrototypeOf()`
- `Object.prototype.propertyIsEnumerable()`

### 属性描述对象

JavaScript 提供一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写，可遍历等待。这个内部数据结构称为"`属性描述对象`"(attributes object)

`Object.getOwnPropertyDescriptor()`
`Object.getOwnPropertyNames()`
`Object.defineProperty()`,`Object.defineProperties()`
`Object.property.prototyIsEnumerable()`

属性描述对象的各个属性称为"元属性", 因此可以看作是控制属性的属性。
`value`属性是目标属性的值
`writable`属性是一个布尔值，决定了目标属性的值 (value) 是否可以被改变。
`enumerable`（可遍历性）返回一个布尔值，表示目标属性是否可遍历。
`configurable`（可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。

除了直接定义以外，属性还可以用存取器 (accessor) 定义。其中，存值函数称为`setter`, 使用属性描述对象的`set`属性；取值函数称为`getter`, 使用描述对象的`get`属性。

一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如定制属性的读取和赋值行为。
注意，取值函数`get`不能接受参数，存值函数`set`只能接受一个参数（即属性的值）
`存取器`往往在于，属性的值依赖对象内部数据的场合。

有时，我们需要将一个对象的所有属性，`拷贝到另一个对象`，可以用下面的方法实现。

`控制对象状态`：有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供三种冻结方法，最弱的一种是`Objec.preventExtensions`, 其次是`Object.seal`, 最强的是`Object.freeze`

`Object.preventExtensions`方法使得一个对象无法再添加新的属性。
`Object.isExtensible`方法用于检查一个对象是否使用了`Object.preventExtensions`方法，也就是说，检查是否可以为一个对象添加属性。

`Object.seal`方法使得一个对象既无法添加新属性，也无法删除旧属性。
`Object.isSealed`方法用于检查一个对象是否使用了`Object.seal`方法。

`Object.freeze`方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。

`Object.isFrozen`方法用于检查一个对象是否使用了`Object.freeze`方法。

上面的三个方法锁定对象的可见性有一个漏洞：可以通过改变原型对象，来为对象增加属性。一种解决方案是，把`obj`的原型也冻住。另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。

### Array 对象

`构造函数`：`Array`是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。`Array()`构造函数有一个很大的缺陷，不同的参数会导致行为不一致。

静态方法：`Array.isArray`方法返回一个布尔值，表示参数是否为数组。它可以弥补`typeof`运算符的不足。

实例方法：`valueOf()`,`toString()`

- `push()`,`pop()`
  `push`方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。

  `pop()`方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。对数组使用`pop`方法，不会报错，而是返回`undefined`

  `push`和`pop`结合使用，就构成了"后进先出"的栈结构 (stack)
- `shift()`,`unshift()`
  `shift()`方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。`shift()`方法可以遍历并清空一个数组。

  `push()`和`shift()`结合使用，就构成了"先进先出"的队列结构 (queue)

  `unshift()`方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。
  `unshift()`方法可以接受多个参数，这些参数都会添加到目标数组头部。
- `join()`
  `join()`方法指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。如果数组成员是`undefined`或`null`或空位，会被转成空字符串。
- `concat()`
  `concat`方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。除了将数组作为参数，`concat`也接受其他类型的值作为参数，添加到目标数组尾部。
  如果数组成员包括对象，`concat`方法返回当前数组的一个浅拷贝。所谓"浅拷贝", 指的是新数组拷贝的是对象的引用。
- `reverse()`
  `reverse`方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。
- `slice()`
  `slice()`方法用于提取目标数组的一部分，返回一个新数组，原数组不变。
  `arr.slice(start,end)`
  它的第一个参数为起始位置（从 0 开始，会包括在返回的新数组之中）, 第二个参数为终止位置（但该位置的元素本身不包括在内）. `如果省略第二个参数，则一直返回原数组的最后一个成员`。如果`slice()`方法的参数是负数，则表示倒数计算的位置。如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。
  `slice()`方法的一个重要作用，是将类似数组的对象转为真正的数组。
- `splice()`
  `splice()`方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。
  `arr.splice(start,count,addElement1,addElement2,...)`
  `splice()`的第一个参数是删除的起始位置（从 0 开始）, 第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是被插入数组的新元素。
  起始位置如果是负数，就表示从倒数位置开始删除。如果只是单独地插入元素，`splice`方法的第二个参数可以设为`0`, 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。
- `sort()`
  `sort`方法对数组成员依此排序，默认是按照字典顺序排序。排序后，原数组将被改变。
  如果想让 `sort` 方法按照自定义方式排序，可以传入一个函数作为参数。
- `map()`
  `map`方法将数组的所有成员依此传入参数函数，然后把每一次的执行结果组成一个新数组返回。
  `map`方法接受一个函数作为参数。该函数调用时，`map`方法向它传入三个参数：当前成员，当前位置和数组本身。`map`方法还可以接受第二个参数，用来绑定回调函数内部的 `this`变量。如果数组有空位，`map`方法的回调函数在这个位置不会执行，会跳过数组的空位。
- `forEach()`
  `forEach`方法与`map`方法很相似，也是对数组的所有成员依此执行参数函数。但是，`forEach`方法不是返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用`map`方法，否则使用`forEach`方法。
  `forEach` 的用法与 `map` 方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。`forEach` 方法也可以接受第二个参数，绑定参数函数的 this 变量。注意，`forEach`方法无法中断执行，总是会将所有成员遍历完。`forEach`方法也会跳过数组的空位。
- `filter()`
  `filter`方法用于过滤数组成员，满足条件的成员组成一个新数组返回。
  它的参数是一个函数，所有数组成员依此执行该函数，返回结果为`true`的成员组成一个新数组返回。该方法不会改变原数组。`filter`方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。`filter` 方法还可以接受第二个参数，用来绑定参数函数内部的 `thi`s 变量。
- `some()`,`every()`
  这两个方法类似"断言"(assert), 返回一个布尔值，表示判断数组成员是否复合某种条件。
  它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。
  `some` 方法是只要一个成员的返回值是 `true`，则整个 `some` 方法的返回值就是 `true`，否则返回 `false`。`every` 方法是所有成员的返回值都是 `true`，整个 `every` 方法才返回 `true`，否则返回 `false`。
  注意，对于空数组，`some`方法返回`false`,`every`方法返回`true`, 回调函数都不会执行。`some`和`every`方法还可以接受第二个参数，用来绑定参数内部的`this`变量。
- `reduce()`,`reduceRight()`
  reduce 方法和 reduceRight 方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce 是从左到右处理（从第一个成员到最后一个成员），reduceRight 则是从右到左（从最后一个成员到第一个成员），其他完全一样。

  reduce 方法和 reduceRight 方法的第一个参数都是一个函数。该函数接受以下四个参数。

  累积变量，默认为数组的第一个成员
  当前变量，默认为数组的第二个成员
  当前位置（从 0 开始）
  原数组

  如果要对累积变量指定初值，可以把它放在 reduce 方法和 reduceRight 方法的第二个参数。
  由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作
- `indexOf()`,`lastIndexOf()`
  `indexOf`方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回 -1
  `indexOf`方法还可以接受第二个参数，表示搜索的开始位置。
  `lastIndexOf` 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回 -1
  注意，这两个方法不能用来搜索 `NaN` 的位置，即它们无法确定数组成员是否包含 `NaN`。

链式调用

### 包装对象

对象是 JavaScript 语言最主要的数据类型，三种原始类型的值；数值，字符串，布尔值，在一定条件下，也会自动转为对象，也就是原始类型的"包装对象"(wrapper)

所谓"包装对象", 指的是于数值，字符串，布尔值分别相对应的`Number`,`String`,`Boolean`三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。

包装对象的设计目的，首先是使得"对象"这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。

这三个对象作为构造函数使用（带有`new`) 时，可以将原始类型的值转为对象；作为普通函数使用时（不带有`new`) 可以将任意类型的值，转为原始类型的值。

三种包装对象各自提供了许多实例方法。从`Object`对象继承的方法：`ValueOf()`和`toString()`

某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。

除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。

### Boolean 对象

`Boolean`对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。注意，`false`对应的包装对象实例，布尔运算结果也是`true`

`Boolean`对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时`Boolean`就是一个单纯的工具方法。

### Number 对象

`Number`对象是数值的包装对象，可以作为构造函数使用，也可以作为工具函数使用。
作为构造函数时，它用于生成值为数值的对象。
作为工具函数时，它可以将任何类型的值转为数值。

`Number`对象拥有以下一些静态属性（即直接定义在`Number`对象上的属性，而不是定义在实例上的属性）.
- Number.POSITION_INFINITY: 正的无限，指向`Infinity`
- Number.NeGATIVE_INFINITY: 负的无限，指向`-Infinity`
- Number.NaN: 表示非数值，指向`NaN`
- NUmber.MIN_VALUE: 表示最小的正数，相应的，最接近 0 的负数为 -Number.MIN_VALUE
- Number.MAX_SAFE_INTEGER: 表示能够精确表示最大整数
- Number.MIN_SAFE_INTEGER: 表示能够精确表示的最小整数

`Number`对象有 4 个实例方法，都跟将数值转换成指定格式有关。
- `Number.prototype.toString()`
- `Number.prototype.toFixed()`
- `Number.prototype.toExponential()`
- `Number.prototype.toPrecision()`
- `Number.prototype.toLocaleString()`

与其他对象一样，`Number.prototype`对象上面可以自定义方法，被`Number`的实例继承。注意，数值的自定义方法，只能定义在它的原型对象 `Number.prototype` 上面，数值本身是无法自定义属性的。

### String 对象

`String`对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。
字符串对象是一个类型数组的对象（很像数组，但不是数组）

除了用作构造函数，`String`对象还可以当作工具方法使用，将任意类型的值转为字符串。

静态方法：
- `String.fromCharCode()`该方法的参数是一个或多个值，代码 Unicode 码点，返回的是这些码点组成的字符串。
实例属性：
- `String.prototype.length`字符串实例的`length`属性返回字符串的长度。
实例方法
- `String.prototype.charAt()`方法返回字符串指定位置的 Unicode 码点。
- `String.prototype.concat()`方法用于连接两个字符串，返回一个新字符串，不改变原字符串。
- `String.prototype.slice()`方法从原字符串取出子字符串并返回，不改变原字符串。
- `String.prototype.substring()`方法从原字符串取出子字符串并返回，不改变原字符串，跟`slice`方法很像。
- `String.prototype.substr()`方法从原字符串中取出子字符串并返回，不改变原字符串，跟`slice`和`substring`方法的作用相同。
- `String.prototype.indexOf()`方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回`-1`就代表不匹配。`indexOf`还可以接受第二个参数，表示该位置开始向后匹配，`String.prototype.lastIndexOf()`方法的用法和`indexOf`方法一致，主要的区别是`lastIndexOf`从尾部开始匹配，`indexOf`则是从头部开始匹配。另外，`lastIndexOf`的第二个参数表示从该位置起向后匹配。
- `String.prototype.trim()`方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符，换行符和回车符
- `String.prototype.toLowerCase()`方法用于将一个字符串全局转为小写，`String.prototype.toUpperCase`则是全部转为大写。它们都返回一个新字符串，不改变原字符串。
- `String.prototype.match()`方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到 1 匹配，则返回`null`. 返回的数组还有`index`属性和`input`属性，分别表示匹配字符串开始的位置和原始字符串。`match`方法还可以使用正则表达式作为参数。
- `String.prototype.search()`方法的用法基本等同于`match`, 但是返回值为匹配的第一个位置。如果没有找到匹配，则返回`-1`.`search`方法还可以使用正则表达式作为参数。`String.prototype.replace`方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用`g`修饰符的正则表达式）
- `String.prototype,split()`方法按照给规则分隔字符串，返回一个由分隔出来的子字符串组成的数组。`split`方法还可以使用正则表达式作为参数。
- `String.prototype.localeCompare`方法用于比较两个字符串。它返回一个整数，如果小于 0, 表示第一个字符串小于第二个字符串；如果等于 0, 表示两者相等；如果大于 0, 表示第一个字符串大于第二个字符串。

### Math 对象

`Math`是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有属性和方法都必须在`Math`对象上调用。

静态属性：Math 对象的静态属性，提供一些数学常数。
- `Math.E`: 常数`e`
- `Math.LN2`:2 的自然对数
- `Math.LN10`:10 的自然对数
- `Math.LOG2E`: 以 2 为底的`e`的对数
- `Math.LOG10E`: 以 10 为底的`e`的对数
- `Math.PI`: 常数`Π`
- `Math.SQRT1_2`:0.5 的平方根
- `Math.SQRT2`:2 的平方根
这些属性都是只读的，不能修改。

静态方法：`Math`对象提供一些静态方法。
- `Math.abs()`: 绝对值
- `Math.ceil()`: 向上取整
- `math.floor()`: 向下取整
- `Math.max()`: 最大值
- `Math.min()`: 最小值
- `Math.pow()`: 幂运算
- `Math.sqrt()`: 平方根
- `Math.log()`: 自然对数
- `Math.exp()`:`e`的指数
- `Math.round()`: 四舍五入
- `math.random()`: 随机数

### Date 对象

`Date`对象是 JavaScript 原生的时间库。它以国际标准时间库 (UTC)1970 年 1 月 1 日 00:00:00 作为时间的零点，可以表示的时间范围是前后各 1 亿天（单位为毫秒）

1. 普通函数的用法：`Date`对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。主要，即使带有参数，`Date`作为普通函数使用时，返回的还是当前时间。
2. 构造函数的用法：`Date`还可以当作构造函数使用。对它使用`new`命令，会返回一个`Date`对象的实例。如果不加参数，实例代表的就是当前时间。`Date`实例有一个独特的地方。其他对象求值的时候，都是调用`.valueOf()`方法，但是`Date`实例求值的时候，默认调用的是`toString()`方法。这导致对`Date`实例就值，返回的是一个字符串，代表该实例对应的时间。作为构造函数的时候，`Date`对象可以接受多种格式的参数，返回一个该参数对应的时间实例。
3. 日期的运算：类型自动转换是，`Date`实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，以两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。
4. 静态方法
  `Date.now()`方法返回当前时间距离时间零点的毫秒数。
  `Date.parse()`方法用来解析日期字符串，返回该时间距离时间零点的毫秒数。
  `Date.UTC()`方法接受年，月，日等变量作为参数，返回该时间距离时间零点的毫秒数。
5. 实例方法：`Date`的实例对象，有几十个自己的方法，除了`valueOf`和`toString`, 可以分位以下三类。
  `to`类：从`Date`对象返回一个字符串，表示指定的时间。
  `get`类：获取`Date`对象的日期和时间。
  `set`类：设置`Date`对象的日期和时间
  `Date.prototype.valueOf()`方法返回实例对象距离时间零点对应的毫秒数，该方法等同于`getTime`方法。预期位数值的场合，`Date`实例会自动调用该方法。
  `Date.prototype.toString()`方法返回一个完整的日期字符串。
  `Date.toUTCString()`方法返回对应的 UTC 时间，也就是比北京时间晚 8 个小时。
  `Date.prototype.toISOString()`方法返回对应时间的 ISO8601 写法。
  `Date.prototype.toJSON()`方法返回一个符合 JSON 格式的 ISO 日期字符串，与 toISOString 方法的返回结果完全相同。
  `Date.prototype.toDateString()`方法返回日期字符串（不含小时，分和秒）
  `Date.prototype.toTimeString()`方法返回时间字符串（不含年月日）
  本地时间：
    `Date.prototype.toLocaleString()`: 完整的本地时间
    `Date.prototype.toLocalDateString()`: 本地日期（不含小时，分和秒）
    `Date.prototype.toLocalTimeString()`: 本地时间（不含年月日）
  这三个方法都有两个可选的参数。这两个参数之中，`locales`是一个指定所用语言的字符串，`options`是一个配置对象。
  `get`类方法：`Date`对象提供了一些`get*`方法，用来获取实例对象某个方面的值。
    `getTime()`: 获取实例距离时间零点的毫秒数，等同于`valueOf`方法。
    `getDate()`: 返回实例对象对应每个月的几号
    `getDay()`: 返回星期即，星期日为 0, 星期一为 1, 以此类推
    `getFullYear()`: 返回四位的年份
    `getMonth()`: 返回月份 (0 表示 1 月，11 表示 12 月）
    `getHours()`: 返回小时 (0-23)
    `getMilliseconds()`: 返回毫秒 (0-999)
    `getMinutes()`: 返回分钟
    `getSeconds()`: 返回秒
    `getTimezoneoffset()`: 返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到夏令时因素。
    上面这些`get*`方法返回的都是当前时区的时间，`Date`对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。
    getUTCDate()
    getUTCFullYear()
    getUTCMonth()
    getUTCDay()
    getUTCHours()
    getUTCMinutes()
    getUTCSeconds()
    getUTCMilliseconds()
  `Date`对象提供了一系列`set*`方法，用来设置实例对象的各个方面
  `setDate(date):`设置实例对象对应的每个月的记号，返回改变后毫秒时间戳
  `setFullYear(year,[,month,date])`设置四位年份
  `setHour(hour,[,min,sec,ms])`: 设置小时
  `setMilliseconds()`: 设置毫秒
  `setMinutes(min [, sec, ms])`：设置分钟（0-59）。
  `setMonth(month [, date])`：设置月份（0-11）。
  `setSeconds(sec [, ms])`：设置秒（0-59）。
  `setTime(milliseconds)`：设置毫秒时间戳。
  `set` 类方法和 `get` 类方法，可以结合使用，得到相对时间。
  `set*`系列方法除了`setTime()`，都有对应的`UTC`版本，即设置 UTC 时区的时间。
  setUTCDate()
  setUTCFullYear()
  setUTCHours()
  setUTCMilliseconds()
  setUTCMinutes()
  setUTCMonth()
  setUTCSeconds()

### RegExp 对象

`RegExp`对象提供正则表达式的功能。正则表达式是一种表达文本模式的方法，有点像字符串的模板，常常用来按照"给定模式"匹配文本。

新建正则表达式有两种方法。一种是`使用字面量`, 以斜杆表示开始和结束。另一种是使用`RegExp`构造函数。`RegExp`构造函数还可以接受第二个参数，表示修饰符。

正则对象的实例属性分成两类。一类是修饰相关，用于了解设置了什么修饰符。
`RegExp.prototype.ignoreCase`: 返回一个布尔值，表示是否设置了`i`修饰符。
`RegExp.prototype.global`: 返回一个布尔值，表示十分设置了`g`修饰符
`RegExp.prototype.multiline`: 返回一个布尔值，表示十分设置了`m`修饰符
`RegExp.prototype.flags`: 返回一个字符串，包含了已经设置的所有修饰符，按字母顺序。
另一类与修饰符无关的属性，主要是下面两个。
`RegExp.prototype.lastIndex`: 返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义
`RegExp.prototype.source`: 返回正则表达式的字符串形式（不包括反斜杠）, 该属性只读

实例方法：`RegExp.prototype.test()`正则实例对象的`test`属性返回一个布尔值，表示当前模式是否能匹配参数字符串。如果正则表达式带有`g`修饰符，则每一次`test`方法都从上一次结束的位置开始向后匹配。带有`g`修饰符时，可以通过正则对象的`lastIndex`属性指定开始搜索的位置。注意，带有`g`修饰符时，正则表达式内部会记住上一次的`lastIndex`属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。`lastIndex`属性只对同一个正则表达式有效。如果正则模式是一个空字符串，则匹配所有字符串。
`RegExp.prototype.exec()`方法，用来返回匹配结果，如果发现匹配，就返回一个数组，成员时匹配成功的子字符串，否则返回`null`. 如果正则表示式包含`圆括号`（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的 length 属性等于组匹配的数量再加 1。`exec()`方法的返回数组还包含以下两个属性：`input`：整个原字符串。`index`：模式匹配成功的开始位置（从 0 开始计数）. 如果正则表达式加上`g`修饰符，则可以使用多次`exec()`方法，下一次搜索的位置从上一次匹配成功结束的位置开始。利用`g`修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。

字符串的实例方法：
`String.prototype.match()`: 返回一个数组，成员是所有匹配的子字符串。
`String.prototype.search()`: 按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
`String.prototype.replace()`: 按照给定的正则表达式进行替换，返回替换后的字符串。
`String.prototype.split()`: 按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员

匹配规则：字面量字符串和元字符，点字符，位置字符，选择符，转义符，特殊字符，字符类，预定义模式，重复类，量词符，贪婪模式，修饰符，组匹配

### JSON 对象

JSON 格式时一种用于数据交换的文本格式。相比 XML 格式，JSON 格式洋浦两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。

JSON 对值的类型和格式由严格的规定。1. 复合类型的值只能是数组或对象，不能是函数，正则表达式对象，日期对象。2. 原始类型的值只有四种：字符串，数值（必须以十进制表示）, 布尔值和`null`（不能使用`NaN`,`Infinity`,`-Infinity`和`undefined`).3. 字符串必须使用双引号表示，不能使用单引号。4. 对象的键名必须放在双引号里面。5. 数组或对象最后一个成员的后面，不能加逗号。5. 数组或对象最后一个成员的后面，不能加逗号。注意，`null`, 空数组和空对象都是和法的 JSON 值。

`JSON`对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：`JSON.stringify()`和`JSON.parse()`

`JSON.stringify`方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被`JSON.parse`还原。注意，对于原始类型的字符串，转换结果会带双引号。如果对象的书写是`undefined`, 函数或 XML 对象，该书写会被`JSON.stringify`过滤，如果数组的成员是 undefined、函数或 XML 对象，则这些值被转成 null。正则对象会被转成空对象，JSON.stringify 方法会忽略对象的不可遍历的属性。

`JSON.stringify`方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。这个类似白名单的数组，只对对象的属性有效，对数组无效。第二个参数还可以是一个函数，用来更改`JSON.stringify`的返回值。注意，这个处理函数是递归处理所有的键。递归处理中，每一次处理的对象，都是前一次返回的值。如果处理函数返回`undefined`或没有返回值，则该属性会被忽略
`JSON.stringify`还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示这个属性前面加的空格，如果是字符粗，则该字符串会添加在每行前面

如果参数对象有自定义的`tJSON`方法，那么`JSON.stringify`或使用这个方法的返回值作为参数，而忽略原对象的其他属性。toJSON 方法的一个应用是，将正则对象自动转为字符串。因为 JSON.stringify 默认不能转换正则对象，但是设置了 toJSON 方法以后，就可以转换正则对象了。

`JSON.parse`方法用于将 JSON 字符串转换成对应的值。如果传入的字符串不是有效的 JSON 格式，`JSON.parse` 方法将报错。`JSON.parse` 方法可以接受一个处理函数，作为第二个参数，用法与 `JSON.stringify` 方法类似。

## 面向对象

### 实例对象与 new 命令

面向对象编程 (Object Oriented Programming, 缩写为 OOP) 是目前主流的编程范式。
对象到底是什么？1. 对象是单个事物的抽象。2. 对象是一个同情，封装了属性和方法。

面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。JavaScript 语言的对象体系，不是基于"类"的，而是基于构造函数 (constructor) 和原型链 (prototype)

JavaScript 语言使用构造函数 (constructor) 作为对象的模板。所谓"构造函数", 就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。构造函数就是一个普通的函数，但是又自己的特征和用法。为了和普通函数区别，构造函数名字的第一个字母通常大写。

构造函数的特点有两个。函数体内部使用了`this`关键字，代表了所要生成的对象实例。生成实例对象的时候，必须使用`new`命令。

`new`命令的作用，就是执行构造函数，返回一个实例对象。使用`new`命令时，根据需要，构造函数也可以接受参数。

`new`命令的原理：使用`new`命令时，它后面的函数依此执行下面的步骤。
1. 创建一个空对象，作为将要返回的对象实例
2. 将这个空对象的原型，指向构造函数的`prototype`属性
3. 将这个空对象赋值给函数内部的`this`关键字
4. 开始执行构造函数内部的代码。

也就是说，构造函数内部，`this`指的是一个新生成的空对象，所有针对`this`的操作，都会发生在这个空对象上。构造函数之所以较"构造函数", 就是说这个函数的目的，就是操作一个空对象（即`this`对象）, 将其"构造"为需要的样子。

如果构造函数内部有`return`语句，而且`return`后面跟着一个对象，`new`命令会返回`return`语句指定的对象；否则，就会不管`return`语句，返回`this`对象。但是，如果`return`语句返回的是一个跟`this`无关的新对象，`new`命令会返回这个新对象，而不是跟`this`对象，这一点需要特别引起注意。另一方面，如果对普通函数（内部没有`this`关键字的函数）使用`new`命令，则会返回一个空对象。

`new`命令简化的内部流程，可以用下面的代码表示

```js
function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {
  // 将 arguments 对象转为数组
  var args = [].slice.call(arguments);
  // 取出构造函数
  var constructor = args.shift();
  // 创建一个空对象，继承构造函数的 prototype 属性
  var context = Object.create(constructor.prototype);
  // 执行构造函数
  var result = constructor.apply(context, args);
  // 如果返回结果是对象，就直接返回，否则返回 context 对象
  return (typeof result === 'object' && result != null) ? result : context;
}

// 实例
var actor = _new(Person, '张三', 28);
```

函数内部可以使用`new.target`属性。如果当前函数是`new`命令调用，`new.target`指向当前函数，否则为`undefined`, 使用这个属性，可以判断函数调用的时候，是否使用 new 命令。

构造函数作为模板，可以生成实例对象。但是，有时候拿不到构造函数，只能拿到一个现有的对象，我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用`Object.create()`方法。

### this 关键字

`this`关键字是一个非常重要的语法点。
`this`可以用在构造函数之中，表示实例对象。除此之外，`this`还可以用在别的场合。但不管是什么场合，`this`都有一个共同点：它总是返回一个对象。简单说，`this`就是属性或方法当前"所在"的对象。由于对象的属性可以赋值给另一个对象，所以属性所在的当前对象是可变的，即`this`的指向是可变的。只要函数赋给另一个变量，`this`的指向就会变。

总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，`this`就是函数运行时所在的对象（环境）,`this`就是函数运行时所在的对象（环境）. 这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，`this`的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者困惑的地方。

JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。
原始的对象以字典结构保存，每一个属性都对应一个属性描述对象。这样的结构是很清晰的，问题在于属性的值可能是一个函数。由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。JavaScript 允许在函数体内部，引用当前环境的其他变量。
现在问题就来了，由于函数可以在不同的运行环境执行，所以需要一种机制，能够在函数体内部获得当前运行环境 (context). 所以，`this`就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。

`this`主要有以下几个使用场合。1. 全局环境使用`this`, 它指的是就是顶层对象`window`2. 构造函数中的`this`, 指的是实例对象。3. 如果对象的方法包含`this`,`this`的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变`this`的指向。

使用注意点：避免多层 this,
由于`this`的指向是不确定的，所以切勿在函数中包含多层的`this`. 避免数组处理方法中的`this`,
数组的`map`和`forEach`方法，允许提供一个阿含作为参数。这个函数内部不应该使用`this`
避免回调函数中的`this`

绑定 this 的方法：`this`的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把`this`固定下来，避免出现意想不到的情况。JavaScript 提供了`call`,`apply`,`bind`这三个方法，来切换 / 固定`this`的指向。

函数实例的`call`方法，可以指定函数内部`this`的指向（即函数执行时所在的作用域）, 然后在所指定的作用域中，调用该函数。`call`方法的参数，应该是一个对象。如果参数为空，`null`和`undefined`, 则默认传入全局对象。如果 `call` 方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入 `call` 方法。`call`方法还可以接受多个参数。`call`的第一个参数就是`this`所要指向的那个对象，后面的参数则是函数调用时所需的参数。`call`方法的一个应用是调用对象的原生方法。

`apply`方法的作用与`call`方法类似，也是改变`this`的指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数。`apply`方法的第一个参数也是 `this` 所要指向的那个对象，如果设为 null 或 undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在 call 方法中必须一个个添加，但是在 apply 方法中，必须以数组形式添加。

`bind()`方法用于将函数体内的`this`绑定到某个对象，然后返回一个新函数。`bind`方法的参数就是所要绑定 `this` 的对象。`this`绑定到其他对象也是可以的。`bind()`还可以接受更多的参数，将这些参数绑定原函数的参数。如果 bind() 方法的第一个参数是 null 或 undefined，等于将 this 绑定到全局对象，函数运行时 this 指向顶层对象（浏览器为 window）。`bind()`方法有一些使用注意点：1. 每一次返回一个新函数。集合回调函数使用，3. 结合`call()`方法使用

### 对象的继承

JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。通过构造函数实例对象定义属性，虽然很方便，但是有一个确定。同一个构造函数的多个实例之间，无法共享属性，从而造成系统资源的浪费。这个问题的解决方法，就是 JavaScript 的原型对象 (prototype)

JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。
下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个`prototype`属性，指向一个对象。对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。如果实例对象自身就有某个属性或方法，它就不含再去原型对象寻找这个属性或方法。总结一下，原型对象的作用，就是丁定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视为原型对象衍生出来的子对象。

JavaScript 规定，所有对象都有自己的原型对象 (prototype). 一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个"原型链"(prototype chain): 对象到原型，再到原型的原型。..

如果一层一层第上溯，所有对象的原型最终都可以上溯到`Object.prototype`, 即`Object`构造函数的`prototype`属性。也就是说，所有对象都继承了`Object.prototype`的属性。这就是所有对象都有`valueOf`和`toString`方法的原因，因为这时从`Object.prototype`继承的。

那么，`Object.prototype`对象有没有它的原型呢？回答是`Object.prototype`的原型是`null`.`null`没有任何属性和方法，也没有自己的原型。因此，原型链的尽头是`null`

读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的`Object.prototype`还是找不到，则返回`undefined`. 如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做"覆盖"(overriding)

注意，一级一级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。

`prototype`对象有一个`constructor`属性，默认指定`prototype`对象所在的构造函数。由于`constructor`属性定义在`prototype`对象上面，意味着可以被所有实例对象继承。`constructor`属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。另一方面，有了`constructor`属性，就可以从一个实例对象新建另一个实例。`constructor`属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改`constructor`属性，防止引用的时候出错。所以，修改原型对象时，一般要同时修改`constructor`属性的指向。如果不能确定`constructor`属性是什么函数，还有一个办法：通过`name`属性，从实例得到构造函数的名称。

`instanceof`运算符返回一个布尔值，表示对象是否为某个构造函数的实例。`instanceof`运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象 (prototype), 是否在左边对象的原型链上。由于`instancof`检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回`true`. 由于任意对象（除了`null`) 都是`Object`的实例，所以`instanceof`运算符可以判断一个值是否为非`null`的对象。`instanceof`的原理是检查右边构造函数的`prototype`属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有`null`对象。这时，`instancof`判断会失真。`instanceof`运算符的一个用处，是判断值的类型。注意，`instanceof`运算符只能用于对象，不适用原始类型的值。此外，对于`undefined`和`null`,`instanceof`运算符总是返回`false`. 利用 `instanceof` 运算符，还可以巧妙地解决，调用构造函数时，忘了加 new 命令的问题

让`一个构造函数继承另一个构造函数`，是非常常见的需求，这可以分成两步事先。第一步是在子类的构造函数中，调用父类的构造函数。第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型

JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。

`模块`是实现特定功能的一组属性和方法的封装。简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。

我们可以利用构造函数，封装私有变量。另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。

如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“`放大模式`”（augmentation）. 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用"宽放大模式"（Loose augmentation）。与"放大模式"相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象

独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。立即执行函数还可以起到命名空间的作用

### Object 对象的相关方法

JavaScript 在 Object 对象上面，提供了很多相关方法，处理面向对象编程的相关操作。

1. `Object.getPrototypeOf()` 方法返回参数对象的原型。
2. `Object.setPrototypeOf()`方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。
3. JavaScript 提供`Object.create`方法，该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。
4. `Object.prototype.isProto()`实例对象的`isPrototypeOf`方法，用来判断是否为参数对象的原型。
5. `Object.prototype.__proto__`实例对象的`__proto__`属性（前后各两个下划线）, 返回该对象的原型。该属性可读写。
6. 获取原型方法的比较
7. `Object.getOwnPropertyNames()`方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。这个方法返回所有键名，不管是否可以遍历
8. `Object.prototype.hasOwnProperty()`对象实例的`hasOwnProperty`方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。
9. in 运算符和 for...in 循环
10. 对象的拷贝：如果要拷贝一个对象，需要做到下面两件事情：1. 确保拷贝后的对象，与原对象具有同样的原型。2. 确保拷贝后的对象，与原对象具有同样的实例属性。利用 ES2017 才引入标准的`Object.getOwnPropertyDescriptors`方法。

```js
function copyObject(orig) {
  return Object.create(
    Object.getPrototypeOf(orig),
    Object.getOwnPropertyDescriptors(orig)
  );
}
```

### 严格模式

除了正常的运行模式，JavaScript 还有第二种运行模式：`严格模式（strict mode）`。顾名思义，这种模式采用更加严格的 JavaScript 语法。

进入严格模式的标志，是一行字符串 use strict。严格模式可以用于整个脚本，也可以只用于单个函数
`显式报错`：只读属性不可写，只设置了取值起的属性不可写，禁止扩展的对象不可扩展，eval,arguments 不可用作标识名，函数不能有重名的参数，禁止八进制的前缀 0 表示法。
`增强的安全措施`：全局变量显式声明，禁止 this 关键字指向全局对象，禁止使用 fn.callee.fn.caller, 禁止使用 arguments.callee、arguments.caller, 禁止删除变量
`静态绑定`：禁止使用 with 语句，创设 eval 作用域，arguments 不再追踪参数的变化。
`向下一个版本的 JavaScript 过渡`；非函数代码块不能声明函数，保留字

## 异步操作

### 概述

`单线程模型`指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程）, 其他线程都是在后台配合。JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。

这种模型的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。先运行后面的任务，等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的"`事件循环`"机制 (Event Loop)

为了利用多核 CPU 的计算能力，HTML5 提出 `Web Worker` 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质

程序里面所有的任务，可以分成两类：`同步任务`和`异步任务`。同步任务是那些没有被引擎挂起，在主线程上排队执行的任务。只有引擎认为某个异步任务可以执行了，该任务才会进入主线程执行。

JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个`任务队列` (task queue), 里面都是各种需要当前程序处理的异步任务。首先，主线程会去执行所有的同步任务。等到同步任务全局执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就会重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。异步任务的写法通常时回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。

JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎再不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做`事件循环`(Event Loop). 维基百科的定义是：事件循环是一个程序结构，用于等待和发送消息和事件。

`回调函数`是异步操作最基本的方法，另一种思路是采用`事件驱动模式`，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。事件完全可以理解成"信号", 如果存在一个"信号中心", 某个任务执行完成，就向信号中心"发布"一个信号，其他任务可以向信号中心"订阅"这个信号，从而知道什么时候自己可以开始执行。这就叫做"`发布订阅模式`", 又称"`观察者模式`"

如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。`串行执行`: 我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。`并行执行`: 流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全局完成以后，才执行 final 函数。
`并行与串行的结合`: 所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行 n 个异步任务，这样就避免了过分占用系统资源。

### 定时器

JavaScript 提供定时执行代码的功能，叫做定时器 (timer), 主要由`setTimeout()`和`setInterval()`这两个函数来完成。它们向任务队列添加定时任务。

`setTimeout`函数用来指定某个函数或代码片段，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。

`setInterval`函数的用法与`setTimeout`完全一致，区别仅仅在于`setInterval`指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行

setTimeout 和 setInterval 函数，都返回一个整数值，表示计数器编号。将该整数传入`clearTimeout`和`clearInterval`函数，就可以取消对应的定时器

`setTimeout`和`setInterval`的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码，如果到了，就执行对应的代码；如果找不到，就继续等待。

这意味着，setTimeout 和 setInterval 指定的回调函数，必须`等到本轮事件循环的所有同步任务都执行完`，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout 和 setInterval 指定的任务，一定会按照预定时间执行。

`setTimeout(f, 0)`会在下一轮事件循环一开始就执行。

### Promise

Promise 的回调函数属于异步任务，会在同步任务之后执行。但是，Promise 的回调函数不是正常的异步任务，而是微任务 (microtask). 它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。
